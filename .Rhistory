break
} else if (i == 1000) {
cat("Did not reach steady state within 1000 iterations")
print(probability)
break
}
i <- i + 1
}
}
eigen.demo <- function(graph, random.factor=0.85) {
nx <- length(graph)
# Check if truly Markov, if not, change problem columns to sum to 1
graph <- check.markov(graph)
# Create Random Walk Matrix (B)
B <- matrix(1/nx,nrow=nx,ncol=nx)
# Create PageRank Matrix based off Transition Matrix (graph) and Random Walk Matrix (B)
M <- (random.factor * graph) + ( (1 - random.factor) * B)
# Create Eigen Vector from the first vector output and change typeof to double (by default, it is complex type)
eigen_vector <- as.double(eigen(M)$vectors[,1])
# Normalize vector such that entire column sum = 1
steady_state_vector <- eigen_vector / sum(eigen_vector)
# Run check to see if Steady State Vector actually sums to 1
check <- sum(steady_state_vector)
if (check == c(1)) {
print(steady_state_vector)
} else
{
print("WARNING: Steady State Vector DOES NOT sum to 1")
print(steady_state_vector)
}
}
markov.demo(load.graph("graph-remus.csv"), print.skip = 20)
markov.demo(load.graph("graph-simple.csv"), print.skip = 5)
load.graph <- function(graph.file) {
# Loads graph for use in other functions in this demo. Assumes named file is in working directory.
#
# Arguments:
#   graph.file: Name of xlsx file containing matrix of a graph of interlinked web pages.
file.data <- read.csv(graph.file)
data.matrix(file.data) # Convert data to matrix, transpose, and return
}
markov.demo <- function(graph, random.factor=0.85, print.skip=3) {
# Demonstrates iterations of Markov Chain using PageRank algorithm
#
# Arguments:
#   graph: Matrix of a graph of interlinked web pages, forming the basis of the transition
#     matrix representing the probability of state change from j to i, i.e. the probability
#     of a hypothetical web surfer following a link from the jth page to the ith page.
#   random.factor: Damping constant to simulate random walk accounting for issue of isolated pages.
#     As written, this factor is the probability that a random surfer will *not*
#     make a jump to a random page but will follow links.
#   print.skip: Skip count when printing graphs to demonstrate iterations.
# initial probability vector
nx <- nrow(graph) # number of nodes/pages
initial <- rep(1 / nx, nx)
# initial <- c(1, rep(0, nx - 1))
probability <- initial
# Minimum difference between iteration probability values
delta_threshold <- 1e-10
i <- 1
# Loop through iterations until resultant PageRank probability vector is stable to threshold delta
repeat{
previous <- probability
# PageRank formula
probability <- (1 - random.factor) / nx + random.factor * (graph %*% probability)
# Print alternate iterations.
if (i == 1 | (i %% print.skip == 0)) {
cat("Iteration", i, ": ")
print(probability)
}
# Check difference between probability and previous probability iteration.
check_vector <- abs(previous - probability)
# If all values in check_vector are less than delta_threshold, print result and end.
if (all(check_vector < delta_threshold)) {
cat("Probabilities converge to steady state vector at iteration number", i, ": ")
print(probability)
break
} else if (i == 1000) {
cat("Did not reach steady state within 1000 iterations")
print(probability)
break
}
i <- i + 1
}
}
#library(readxl) # package to read excel files
markov.demo(load.graph("graph-simple.csv"), print.skip = 5)
markov.demo(load.graph("graph-remus.csv"), print.skip = 5)
markov.demo(load.graph("graph-single-hub.csv"), print.skip = 5)
markov.demo(load.graph("graph-massive-ball.csv"), print.skip = 5)
nx <- nrow(graph) # number of nodes/pages
# Gian's Work in Progress on Eigenvector calculation:
######################################################
######################################################
######################################################
######################################################
######################################################
# Proposed eigen value code
# install.packages("pracma")
library(pracma)
## Check if each column sums to 1, if not then over write it so that each value in the column = 1/nx
for (i in 1:nx)
{ #loops every new probability until it normalized.
if (sum(graph[,i]) != 1) {
graph[,i] <- 1/nx
}
}
# Create Random Walk Matrix (B)
B <- matrix(1/nx,nrow=nx,ncol=nx)
# Create PageRank Matrix based off Transition Matrix (graph) and Random Walk Matrix (B)
M <- (random.factor * graph) + ( (1 - random.factor) * B)
# Create Eigen Vector from the first vector output and change typeof to double (by default, it is complex type)
eigen_vector <- as.double(eigen(M)$vectors[,1])
# Normalize vector such that entire column sum = 1
steady_state_vector <- eigen_vector / sum(eigen_vector)
print(steady_state_vector)
# Run check to see if Steady State Vector actually sums to 1
check <- sum(steady_state_vector)
if (check == c(1)) {
print("Steady State Vector sums to 1")
} else
{
print("Steady State Vector DOES NOT sum to 1")
}
######## Scratch work / notes
######################### EIGEN VECTOR CALCULATION
### NOTE: THIS WILL NOT WORK UNLESS ENTIRE COLUMNS ADD UP TO 1 SO EVERY NODE MUST HAVE AT LEAST 1 LINK
# install.packages("pracma")
library(pracma)
# Since this is a positive column Stochastic Model (the sum of every column = 1), then 1 is ALWAYS an eigen value and ALWAYS the largest eigen value. This should theoretically correspond with the first eigenvector (We may need to check this in other calculations)
# Test with THIS matrix first (exact same from Cornell)
(graph <- matrix(c(0, 1/3, 1/3, 1/3, 0, 0, 1/2, 1/2, 1, 0 ,0 ,0 ,1/2 ,0 ,1/2 , 0), ncol=4))
(eigen_vector <- eigen(graph)$vectors[,1])
# Normalize vector such that entire column sum = 1
(steady_state_vector <- eigen_vector / sum(eigen_vector))
# Try this with Haroon's Example 1 WITH DANGLING SITE.
# THIS EQUATION INCLUDES the Random Walk into the matrix.
# HOWEVER, it won't fix any dangling nodes (columns that don't add up to 1). We need to include that somewhere in the code as a check.
# graph will be our Transition Matrix now. We will combine it with the Random Walk Matrix and Random Walk probability (random.factor) to create our PageRank Matrix (M)
#
(graph <- matrix(c(0, 0, 0, 0, 1/2, 0, 1/2, 0, 1, 0 ,0 ,0 ,1/3 ,1/3 ,1/3 , 0), ncol=4))
# Random Walk Matrix (same dimensions as graph, but divided evenly in each column since equal probability of jumping from one site to the other)
(B <- matrix(1/nx,nrow=nx,ncol=nx))
# Create new matrix M (PageRank Matrix) that keeps 85% of weight to original matrix and 15% to the random walk. Random walk is also known as a "damping factor"
(M <- (random.factor * graph) + ( (1 - random.factor) * B))
# This gives us the wrong Eigenvalue...since column 1 does not add up to 1.
eigen(M)
## RECOMMENDATION:
# Maybe we can run a check to see if each column sums to 1? and if not, rewrite the column to be 1/nx before proceeding. This is an idea below (not actual code that will work)
if (sum(graph[,i]) != 1) {
graph[,i] <- 1/nx
}
delta_threshold <- 1e-7
markov.demo <- function(graph, random.factor=0.85, print.skip=3) {
# Demonstrates iterations of Markov Chain using PageRank algorithm
#
# Arguments:
#   graph: Matrix of a graph of interlinked web pages, forming the basis of the transition
#     matrix representing the probability of state change from j to i, i.e. the probability
#     of a hypothetical web surfer following a link from the jth page to the ith page.
#   random.factor: Damping constant to simulate random walk accounting for issue of isolated pages.
#     As written, this factor is the probability that a random surfer will *not*
#     make a jump to a random page but will follow links.
#   print.skip: Skip count when printing graphs to demonstrate iterations.
# initial probability vector
nx <- nrow(graph) # number of nodes/pages
initial <- rep(1 / nx, nx)
# initial <- c(1, rep(0, nx - 1))
probability <- initial
# Minimum difference between iteration probability values
delta_threshold <- 1e-7
i <- 1
# Loop through iterations until resultant PageRank probability vector is stable to threshold delta
repeat{
previous <- probability
# PageRank formula
probability <- (1 - random.factor) / nx + random.factor * (graph %*% probability)
# Print alternate iterations.
if (i == 1 | (i %% print.skip == 0)) {
cat("Iteration", i, ": ")
print(probability)
}
# Check difference between probability and previous probability iteration.
check_vector <- abs(previous - probability)
# If all values in check_vector are less than delta_threshold, print result and end.
if (all(check_vector < delta_threshold)) {
cat("Probabilities converge to steady state vector at iteration number", i, ": ")
print(probability)
break
} else if (i == 1000) {
cat("Did not reach steady state within 1000 iterations")
print(probability)
break
}
i <- i + 1
}
}
markov.demo(load.graph("graph-remus.csv"), print.skip = 5)
delta_threshold <- 1e-8
markov.demo(load.graph("graph-remus.csv"), print.skip = 5)
delta_threshold <- 1e-9
markov.demo(load.graph("graph-remus.csv"), print.skip = 5)
markov.demo(load.graph("graph-remus.csv"), print.skip = 20)
delta_threshold <- 1e-8
markov.demo(load.graph("graph-remus.csv"), print.skip = 10)
load.graph <- function(graph.file) {
file.data <- read.csv(graph.file)
data.matrix(file.data) # Convert data to matrix, transpose, and return
}
check.markov <- function(graph) {
# Checks that the sum of every column = 1.
#   If it adds to 1, return the graph unchanged.
#   If it adds to 0 (dangling node), return an adjusted graph, create each value
#     as 1/nx where nx is total number of nodes.
#   If it does not add to 1 and is not a dangling node, return FALSE. This represents
#     an error in the matrix itself.
#
# Arguments:
#   graph: Matrix of a graph of interlinked web pages
nx <- nrow(graph)
# Loop through columns and normalize.
adjusted <- FALSE
for (i in 1:nx) {
colsum <- sum(graph[,i])
if (!isTRUE(all.equal(colsum,1, tolerance=0.0001))) {
if (colsum == 0) {
graph[,i] <- 1/nx
adjusted <- TRUE
} else {
return(FALSE)
}
}
}
if (adjusted) {
message("Graph adjusted to correct dangling nodes:")
print(graph)
}
return(graph)
}
graph
markov.demo <- function(graph, initial, random.factor=0.85, print.skip=3) {
# Demonstrates iterations of Markov Chain using PageRank algorithm
#
# Arguments:
#   graph: Matrix of a graph of interlinked web pages, forming the transition matrix
#     representing the probability of state change from j to i, i.e. the probability
#     of a hypothetical web surfer following a link from the jth page to the ith page.
#   initial: Initial probability vector.
#   random.factor: Damping constant simulates random walk accounting for isolated pages.
#     As written, this factor is the probability that a random surfer will *not*
#     make a jump to a random page but will follow links.
#     Set random.factor to 1 to simulate basic Markov Chain without damping.
#   print.skip: Skip count when printing graphs to demonstrate iterations.
nx <- nrow(graph) # number of nodes/pages
probability <- initial
message("Graph input, representing original transition matrix:")
print(graph)
# Check if truly Markov, if not, change problem columns to sum to 1
graph <- check.markov(graph)
if (graph[1] == FALSE & length(graph) == 1) {
stop("ERROR: Data is not properly formatted.")
}
# Minimum difference between iteration probability values
delta_threshold <- 1e-7
# Iterate until PageRank probability vector is stable to threshold delta, or max 1000 iterations
for (i in 1:1000) {
previous <- probability
# PageRank formula
probability <- (1 - random.factor) / nx + random.factor * (graph %*% probability)
# Print alternate iterations.
if (i %in% 1:5 | (i %% print.skip == 0)) {
message("Iteration ", i, " PageRank (probability) vector: ")
print(probability)
}
# Check difference between probability and previous probability iteration.
check_vector <- abs(previous - probability)
# If all values in check_vector are less than delta_threshold, print result and end.
if (all(check_vector < delta_threshold)) {
message("Probabilities converge to steady state vector at iteration number ", i, ": ")
return(probability)
break
}
}
message("Did not reach steady state within 1000 iterations.")
print(probability)
}
eigen.demo <- function(graph, random.factor=0.85) {
nx <- length(graph)
# Check if truly Markov, if not, change problem columns to sum to 1
#graph <- check.markov(graph)
# Create Random Walk Matrix (B)
B <- matrix(1/nx,nrow=nx,ncol=nx)
# Create PageRank Matrix based off Transition Matrix (graph) and Random Walk Matrix (B)
M <- (random.factor * graph) + ((1 - random.factor) * B)
# Create Eigen Vector from the first vector output and change typeof to double (by default, it is complex type)
eigen_vector <- as.double(eigen(M)$vectors[,1])
# Normalize vector such that entire column sum = 1
steady_state_vector <- eigen_vector / sum(eigen_vector)
# Run check to see if Steady State Vector actually sums to 1
check <- sum(steady_state_vector)
if (check == c(1)) {
print(steady_state_vector)
} else {
print("WARNING: Steady State Vector DOES NOT sum to 1")
print(steady_state_vector)
}
}
```
graph <- load.graph("graph-massive-ball.csv")
nx <- nrow(graph)
initial <- rep(1 / nx, nx)
markov.demo(graph, initial, print.skip = 5)
graph <- load.graph("graph-massive-ball.csv")
nx <- nrow(graph)
graph
graph <- load.graph("graph-single-hub.csv")
markov.demo(graph, initial, print.skip = 5)
graph <- load.graph("graph-hub-transfer.csv")
graph
markov.demo(graph, initial, print.skip = 40)
graph <- load.graph("graph-dual-hub.csv")
nx <- nrow(graph)
initial <- rep(1 / nx, nx)
graph
markov.demo(graph, initial, print.skip = 20)
graph <- load.graph("graph-dual-hub.csv")
check.markov(graph)
graph
graph[1]
graph[2]
graph[3]
graph[11]
graph[13]
graph[14]
length(graph)
graph
nx <- nrow(graph)
initial <- rep(1 / nx, nx)
markov.demo(graph, initial, print.skip = 20)
eigen.demo(graph)
length(graph)
graph
random.factor=0.85
nx <- length(graph)
length(graph)
nx
nx <- nrow(graph)
nx
B <- matrix(1/nx,nrow=nx,ncol=nx)
M <- (random.factor * graph) + ((1 - random.factor) * B)
M
B
eigen.demo <- function(graph, random.factor=0.85) {
nx <- nrow(graph)
# Check if truly Markov, if not, change problem columns to sum to 1
#graph <- check.markov(graph)
# Create Random Walk Matrix (B)
B <- matrix(1/nx,nrow=nx,ncol=nx)
# Create PageRank Matrix based off Transition Matrix (graph) and Random Walk Matrix (B)
M <- (random.factor * graph) + ((1 - random.factor) * B)
# Create Eigen Vector from the first vector output and change typeof to double (by default, it is complex type)
eigen_vector <- as.double(eigen(M)$vectors[,1])
# Normalize vector such that entire column sum = 1
steady_state_vector <- eigen_vector / sum(eigen_vector)
# Run check to see if Steady State Vector actually sums to 1
check <- sum(steady_state_vector)
if (check == c(1)) {
print(steady_state_vector)
} else {
print("WARNING: Steady State Vector DOES NOT sum to 1")
print(steady_state_vector)
}
}
eigen.demo(graph)
steady_state_test <- eigen.demo(graph)
steady_state_test
sum(steady_state_test)
typeof(B)
typeof(M)
eigen_vector <- as.double(eigen(M)$vectors[,1])
steady_state_vector <- eigen_vector / sum(eigen_vector)
typeof(steady_state_vector)
check <- sum(steady_state_vector)
check
if (check == c(1)) {
print(steady_state_vector)
} else {
print("WARNING: Steady State Vector DOES NOT sum to 1")
print(steady_state_vector)
}
check == c(1)
typeof(c(1))
typeof(check)
check
c(1)
check[1]
as.complex(check[1])
as.complex(c(1))
as.complex(check[1]) == as.complex(c(1))
identical(check,c(1))
identical(check,1)
identical(check[1],1)
identical(check[1],c(1)
identical(check[1],c(1))
identical(check[1],c(1))
all.equal(check[1],c(1))
all.equal(check,c(1))
check == c(1)
if (all.equal(check,c(1))) {
print(steady_state_vector)
} else {
print("WARNING: Steady State Vector DOES NOT sum to 1")
print(steady_state_vector)
}
markov.demo <- function(graph, initial, random.factor=0.85, print.skip=3) {
# Demonstrates iterations of Markov Chain using PageRank algorithm
#
# Arguments:
#   graph: Matrix of a graph of interlinked web pages, forming the transition matrix
#     representing the probability of state change from j to i, i.e. the probability
#     of a hypothetical web surfer following a link from the jth page to the ith page.
#   initial: Initial probability vector.
#   random.factor: Damping constant simulates random walk accounting for isolated pages.
#     As written, this factor is the probability that a random surfer will *not*
#     make a jump to a random page but will follow links.
#     Set random.factor to 1 to simulate basic Markov Chain without damping.
#   print.skip: Skip count when printing graphs to demonstrate iterations.
nx <- nrow(graph) # number of nodes/pages
probability <- initial
message("Graph input, representing original transition matrix:")
print(graph)
# Check if truly Markov, if not, change problem columns to sum to 1
graph <- check.markov(graph)
if (graph[1] == FALSE & length(graph) == 1) {
stop("ERROR: Data is not properly formatted.")
}
# Minimum difference between iteration probability values
delta_threshold <- 1e-7
# Iterate until PageRank probability vector is stable to threshold delta, or max 1000 iterations
for (i in 1:1000) {
previous <- probability
# PageRank formula
probability <- (1 - random.factor) / nx + random.factor * (graph %*% probability)
# Print alternate iterations.
if (i %in% 1:5 | (i %% print.skip == 0)) {
message("Iteration ", i, " PageRank (probability) vector: ")
print(probability)
}
# Check difference between probability and previous probability iteration.
check_vector <- abs(previous - probability)
# If all values in check_vector are less than delta_threshold, print result and end.
if (all(check_vector < delta_threshold)) {
message("Probabilities converge to steady state vector at iteration number ", i, ": ")
return(probability)
break
}
}
message("Did not reach steady state within 1000 iterations.")
print(probability)
}
eigen.demo <- function(graph, random.factor=0.85) {
nx <- nrow(graph)
# Check if truly Markov, if not, change problem columns to sum to 1
#graph <- check.markov(graph)
# Create Random Walk Matrix (B)
B <- matrix(1/nx,nrow=nx,ncol=nx)
# Create PageRank Matrix based off Transition Matrix (graph) and Random Walk Matrix (B)
M <- (random.factor * graph) + ((1 - random.factor) * B)
# Create Eigen Vector from the first vector output and change typeof to double (by default, it is complex type)
eigen_vector <- as.double(eigen(M)$vectors[,1])
# Normalize vector such that entire column sum = 1
steady_state_vector <- eigen_vector / sum(eigen_vector)
# Run check to see if Steady State Vector actually sums to 1
check <- sum(steady_state_vector)
if (all.equal(check,c(1))) {
print(steady_state_vector)
} else {
print("WARNING: Steady State Vector DOES NOT sum to 1")
print(steady_state_vector)
}
}
eigen.demo(graph)
markov.demo(graph, initial, print.skip = 20)
check
steady_state_vector <- eigen_vector / sum(eigen_vector)
stead_state_vector
steady_state_vector
trans(steady_state_vector)
t(steady_state_vector)
strf(steady_state_vector)
str(steady_state_vector)
str(steady_state_vector)
str(markov.demo(graph, initial, print.skip = 20))
(steady_state_vector)
dim(steady_state_vector)
as.vector(steady_state_vector)
t(steady_state_vector)
t(steady_state_vector)
as.vector(steady_state_vector)
?eigen
?eigen(graph)$vectors[,1])
eigen(graph)$vectors[,1])
?eigen(graph)$vectors[,1]
eigen(graph)$vectors[,1]
str(eigen(graph)$vectors[,1])
typeof(eigen(graph)$vectors[,1])
t(eigen(graph)$vectors[,1])
graph <- load.graph("graph-dual-hub.csv")
nx <- nrow(graph)
initial <- rep(1 / nx, nx)
markov.demo(graph, initial, print.skip = 20)
eigen.demo(graph)
