print(n)
}
pb <- scan(text = readline(prompt = "Give the initial probability of being on a page \n"))
for (i in 1:50){ #loops every new probability until it normalized.
#PageRank formula. Dot product of website matrix with probability vector.
pb_temp <- pb
pb <-  (1-gp)/nx + gp*(website%*%pb)
check_vector <- abs(pb_temp - pb)
for (n in 1:nx) {
if ( check_vector[n] < delta_threshold) {
print(pb)
print(i)
break
}
}
}
?break
pb <- scan(text = readline(prompt = "Give the initial probability of being on a page \n"))
for (i in 1:50){ #loops every new probability until it normalized.
#PageRank formula. Dot product of website matrix with probability vector.
pb_temp <- pb
pb <-  (1-gp)/nx + gp*(website%*%pb)
check_vector <- abs(pb_temp - pb)
for (n in 1:nx) {
if ( check_vector[n] > delta_threshold) {
}
print(pb)
print(i)
break
}
}
pb <- scan(text = readline(prompt = "Give the initial probability of being on a page \n"))
for (i in 1:50) { #loops every new probability until it normalized.
#PageRank formula. Dot product of website matrix with probability vector.
pb_temp <- pb
pb <-  (1-gp)/nx + gp*(website%*%pb)
check_vector <- abs(pb_temp - pb)
check_bool <- FALSE
for (n in 1:nx) {
if ( check_vector[n] < delta_threshold) {
check_bool <- TRUE
}
else {
check_bool <- FALSE
}
if (check_bool == TRUE) {
return(pb)
return(i)
}
}
}
pb <- scan(text = readline(prompt = "Give the initial probability of being on a page \n"))
for (i in 1:50) { #loops every new probability until it normalized.
#PageRank formula. Dot product of website matrix with probability vector.
pb_temp <- pb
pb <-  (1-gp)/nx + gp*(website%*%pb)
check_vector <- abs(pb_temp - pb)
check_bool <- FALSE
for (n in 1:nx) {
if ( check_vector[n] < delta_threshold) {
check_bool <- TRUE
}
else {
check_bool <- FALSE
}
if (check_bool == TRUE) {
print(pb)
print(i)
}
}
}
pb <- c(1, 0, 0 , 0)
for (i in 1:50) { #loops every new probability until it normalized.
#PageRank formula. Dot product of website matrix with probability vector.
pb_temp <- pb
pb <-  (1-gp)/nx + gp*(website%*%pb)
check_vector <- abs(pb_temp - pb)
check_bool <- FALSE
for (n in 1:nx) {
if ( check_vector[n] < delta_threshold) {
check_bool <- TRUE
}
else {
check_bool <- FALSE
}
if (check_bool == TRUE) {
print(pb)
print(i)
break
}
}
}
pb <- c(1, 0, 0 , 0)
delta_threshold <- 1e-10
for (i in 1:50) { #loops every new probability until it normalized.
#PageRank formula. Dot product of website matrix with probability vector.
pb_temp <- pb
pb <-  (1-gp)/nx + gp*(website%*%pb)
check_vector <- abs(pb_temp - pb)
check_bool <- FALSE
break_key <- FALSE
for (n in 1:nx) {
if ( check_vector[n] < delta_threshold) {
check_bool <- TRUE
}
else {
check_bool <- FALSE
}
if (check_bool == TRUE) {
print(pb)
print(i)
break_key <- TRUE
break
}
}
if (break_key == TRUE) {
break
}
}
print(i)
print(i + "iteration")
pb <- scan(text = readline(prompt = "Give the initial probability of being on a page \n"))
for (i in 1:50)
{ #loops every new probability until it normalized.
#PageRank formula. Dot product of website matrix with probability vector.
pb_temp <- pb
pb <-  (1-gp)/nx + gp*(website%*%pb)
# Created checks and differences between pb and previous pb iteration (aka check_vector)
check_vector <- abs(pb_temp - pb)
check_bool <- FALSE
break_key <- FALSE
# Run this over every element in check_vector
for (n in 1:nx)
{
# If every value in check_vector are less than 1e-10, change check_bool to TRUE. Otherwise change it back to FALSE.
if ( check_vector[n] < delta_threshold)
{
check_bool <- TRUE
}
else
{
check_bool <- FALSE
}
# If check_bool stays TRUE, then print pb table, iteration number and change break_key to TRUE...then break out of FOR (n in 1:nx) loop
if (check_bool == TRUE)
{
print("Probabilities converge to steady state vector")
print(pb)
print("At iteration number")
print(i)
break_key <- TRUE
break
}
}
# If break_key is TRUE, then break out of FOR (i in 1:50) loop too. Without this, code will keep running and printing every iteration afterwards
if (break_key == TRUE)
{
break
}
}
website <- read_excel("websites.xlsx") # get data from excel
library(readxl) #package to read excel files
website <- read_excel("websites.xlsx") # get data from excel
website
website <- data.matrix(website) # convert data to matrix and transpose
website
library(readxl) #package to read excel files
website <- read_excel("websites.xlsx") # get data from excel
nx <- length(website) #numbers of nodes/pages
website <- data.matrix(website) # convert data to matrix and transpose
gp <- .85 # google prob of going from a link
#probability of being on a page. Here I set the 1st interation to A as a homepage
pb <- scan(text = readline(prompt = "Give the initial probability of being on a page \n"))
delta_threshold <- 1e-10
pb <- scan(text = readline(prompt = "Give the initial probability of being on a page \n"))
for (i in 1:50)
{ #loops every new probability until it normalized.
#PageRank formula. Dot product of website matrix with probability vector.
pb_temp <- pb
pb <-  (1-gp)/nx + gp*(website%*%pb)
# Created checks and differences between pb and previous pb iteration (aka check_vector)
check_vector <- abs(pb_temp - pb)
check_bool <- FALSE
break_key <- FALSE
# Run this over every element in check_vector
for (n in 1:nx)
{
# If every value in check_vector are less than 1e-10, change check_bool to TRUE. Otherwise change it back to FALSE.
if ( check_vector[n] < delta_threshold)
{
check_bool <- TRUE
}
else
{
check_bool <- FALSE
}
# If check_bool stays TRUE, then print pb table, iteration number and change break_key to TRUE...then break out of FOR (n in 1:nx) loop
if (check_bool == TRUE)
{
print("Probabilities converge to steady state vector")
return(pb)
print("At iteration number")
return(i)
break_key <- TRUE
break
}
}
# If break_key is TRUE, then break out of FOR (i in 1:50) loop too. Without this, code will keep running and printing every iteration afterwards
if (break_key == TRUE)
{
break
}
}
library(readxl) #package to read excel files
website <- read_excel("websites.xlsx") # get data from excel
nx <- length(website) #numbers of nodes/pages
website <- data.matrix(website) # convert data to matrix and transpose
website
website - diag(nx)
solve((website - diag(nx)))
test <- website - diag(nx)
test
solve(test)
det(test)
test_2 <- test(test,c(0,0,0,0))
test_2 <- append(test,c(0,0,0,0))
test_2
test <- website - diag(nx)
test_2 <- append(test,c(0,0,0,0), byrow=FALSE)
test_2 <- append(test,c(0,0,0,0), bycol=TRUE)
test <- website - diag(nx)
test_2 <- append(test,t(c(0,0,0,0)))
test_2
test_2 <- cbind(test,c(0,0,0,0))
test_2
det(test_2)
rref(test_2)
install.packages("pracma")
library(pracma)
rref(test_2)
test_2
test <- website - diag(nx)
test_2 <- cbind(test,c(0,0,0,0))
test_2
test
rref(test_2)
solution(,3)/(-4)
solution[,3]/(-4)
solution <- rref(test_2)
solution[,3]/(-4)
solution <- rref(test_2)
solution[,4]/(-4)
eigen(website)
pb <- scan(text = readline(prompt = "Give the initial probability of being on a page \n"))
delta_threshold <- 1e-10
for (i in 1:50)
{ #loops every new probability until it normalized.
#PageRank formula. Dot product of website matrix with probability vector.
pb_temp <- pb
pb <-  (1-gp)/nx + gp*(website%*%pb)
# Created checks and differences between pb and previous pb iteration (aka check_vector)
check_vector <- abs(pb_temp - pb)
check_bool <- FALSE
break_key <- FALSE
# Run this over every element in check_vector
for (n in 1:nx)
{
# If every value in check_vector are less than 1e-10, change check_bool to TRUE. Otherwise change it back to FALSE.
if ( check_vector[n] < delta_threshold)
{
check_bool <- TRUE
}
else
{
check_bool <- FALSE
}
# If check_bool stays TRUE, then print pb table, iteration number and change break_key to TRUE...then break out of FOR (n in 1:nx) loop
if (check_bool == TRUE)
{
print("Probabilities converge to steady state vector")
print(pb)
print("At iteration number")
print(i)
break_key <- TRUE
break
}
}
# If break_key is TRUE, then break out of FOR (i in 1:50) loop too. Without this, code will keep running and printing every iteration afterwards
if (break_key == TRUE)
{
break
}
}
eigen(website)
website <- matrix(c(0, 1/3, 1/3, 1/3, 0, 0 , 1/2, 1/2, 1, 0, ,0 ,0,1/2, 0 , 1/2, 0, ), ncol=4)
website <- matrix(c(0, 1/3, 1/3, 1/3, 0, 0, 1/2, 1/2, 1, 0 ,0 ,0 ,1/2 ,0 ,1/2 , 0), ncol=4)
website
eigen(website)
eigen(website)$vectors[,1]
testing <- eigen(website)$vectors[,1]
testing/2
sum(testing)
testing_2 <- testing / sum(testing)
testing_2
website <- read_excel("websites.xlsx") # get data from excel
website <- data.matrix(website) # convert data to matrix and transpose
eigen_vector <- eigen(website)$vectors[,1]
# Normalize vector such that entire column sum = 1
steady_state_vector <- eigen_vector / sum(eigen_vector)
steady_state_vector
(website <- matrix(c(0, 1/3, 1/3, 1/3, 0, 0, 1/2, 1/2, 1, 0 ,0 ,0 ,1/2 ,0 ,1/2 , 0), ncol=4))
(website <- matrix(c(0, 1/3, 1/3, 1/3, 0, 0, 1/2, 1/2, 1, 0 ,0 ,0 ,1/2 ,0 ,1/2 , 0), ncol=4))
(website <- matrix(c(0, 0, 0, 0, 1/2, 0, 1/2, 0, 1, 0 ,0 ,0 ,1/3 ,1/3 ,1/3 , 0), ncol=4))
(eigen_vector <- eigen(website)$vectors[,1])
(steady_state_vector <- eigen_vector / sum(eigen_vector))
for (i in 1:50)
{ #loops every new probability until it normalized.
#PageRank formula. Dot product of website matrix with probability vector.
pb_temp <- pb
pb <-  (1-gp)/nx + gp*(website%*%pb)
# Created checks and differences between pb and previous pb iteration (aka check_vector)
check_vector <- abs(pb_temp - pb)
check_bool <- FALSE
break_key <- FALSE
# Run this over every element in check_vector
for (n in 1:nx)
{
# If every value in check_vector are less than 1e-10, change check_bool to TRUE. Otherwise change it back to FALSE.
if ( check_vector[n] < delta_threshold)
{
check_bool <- TRUE
}
else
{
check_bool <- FALSE
}
# If check_bool stays TRUE, then print pb table, iteration number and change break_key to TRUE...then break out of FOR (n in 1:nx) loop
if (check_bool == TRUE)
{
print("Probabilities converge to steady state vector")
print(pb)
print("At iteration number")
print(i)
break_key <- TRUE
break
}
}
# If break_key is TRUE, then break out of FOR (i in 1:50) loop too. Without this, code will keep running and printing every iteration afterwards
if (break_key == TRUE)
{
break
}
}
pb <- scan(text = readline(prompt = "Give the initial probability of being on a page \n"))
for (i in 1:50)
{ #loops every new probability until it normalized.
#PageRank formula. Dot product of website matrix with probability vector.
pb_temp <- pb
pb <-  (1-gp)/nx + gp*(website%*%pb)
}
pb #the results
sum(pb)
pb <- scan(text = readline(prompt = "Give the initial probability of being on a page \n"))
for (i in 1:50)
{ #loops every new probability until it normalized.
#PageRank formula. Dot product of website matrix with probability vector.
pb_temp <- pb
pb <-  (1-gp)/nx + gp*(website%*%pb)
# Created checks and differences between pb and previous pb iteration (aka check_vector)
check_vector <- abs(pb_temp - pb)
check_bool <- FALSE
break_key <- FALSE
# Run this over every element in check_vector
for (n in 1:nx)
{
# If every value in check_vector are less than 1e-10, change check_bool to TRUE. Otherwise change it back to FALSE.
if ( check_vector[n] < delta_threshold)
{
check_bool <- TRUE
}
else
{
check_bool <- FALSE
}
# If check_bool stays TRUE, then print pb table, iteration number and change break_key to TRUE...then break out of FOR (n in 1:nx) loop
if (check_bool == TRUE)
{
print("Probabilities converge to steady state vector")
print(pb)
print("At iteration number")
print(i)
break_key <- TRUE
break
}
}
# If break_key is TRUE, then break out of FOR (i in 1:50) loop too. Without this, code will keep running and printing every iteration afterwards
if (break_key == TRUE)
{
break
}
}
sum(pb)
(website <- matrix(c(0, 0, 0, 0, 1/2, 0, 1/2, 0, 1, 0 ,0 ,0 ,1/3 ,1/3 ,1/3 , 0), ncol=4))
website <- read_excel("websites.xlsx") # get data from excel
website <- data.matrix(website) # convert data to matrix and transpose
website
B <- matrix(1/nx,nrow=nx,ncol=nx)
B
(gp * A) + ( (1 - gp) * B)
website <- read_excel("websites.xlsx") # get data from excel
nx <- length(website) #numbers of nodes/pages
website <- data.matrix(website) # convert data to matrix and transpose
(gp * website) + ( (1 - gp) * B)
(website <- matrix(c(0, 0, 0, 0, 1/2, 0, 1/2, 0, 1, 0 ,0 ,0 ,1/3 ,1/3 ,1/3 , 0), ncol=4))
B <- matrix(1/nx,nrow=nx,ncol=nx)
(gp * website) + ( (1 - gp) * B)
M <- (gp * website) + ( (1 - gp) * B)
sum(M[,2])
sum(M[,3])
sum(M[,4])
(B <- matrix(1/nx,nrow=nx,ncol=nx))
(website <- matrix(c(0, 0, 0, 0, 1/2, 0, 1/2, 0, 1, 0 ,0 ,0 ,1/3 ,1/3 ,1/3 , 0), ncol=4))
(B <- matrix(1/nx,nrow=nx,ncol=nx))
# Create new matrix M (PageRank Matrix) that keeps 85% of weight to original matrix and 15% to the random walk. Random walk is also known as a "damping factor"
(M <- (gp * website) + ( (1 - gp) * B))
eigen(M)
website[,1]
website[,1] <- 1/nx
website
for (i in 1:nx)
{ #loops every new probability until it normalized.
if (sum(website[,i]) != 1) {
website[,i] <- 1/nx
}
}
B <- matrix(1/nx,nrow=nx,ncol=nx)
M <- (gp * website) + ( (1 - gp) * B)
eigen_vector <- eigen(M)$vectors[,1]
eigen_vector
# Normalize vector such that entire column sum = 1
steady_state_vector <- eigen_vector / sum(eigen_vector)
steady_state_vector
sum(steady_state_vector)
if ( sum(steady_state_vector) == 1) {
print("TRUE")
}
check <- sum(steady_state_vector)
?info
?type
typeof(check)
check <- double(sum(steady_state_vector))
check
?double
check <- as.double(sum(steady_state_vector))
typeof(check)
check
if (check == 1) {
print("Steady State Vector sums to 1")
}
else {
print("Steady State Vector DOES NOT sum to 1")
}
if (check == 1) {
print("Steady State Vector sums to 1")
}
else
{
print("Steady State Vector DOES NOT sum to 1")
}
if (check == 1) {
print("Steady State Vector sums to 1")
} else
{
print("Steady State Vector DOES NOT sum to 1")
}
check
check <- as.double(sum(steady_state_vector))
check
check[1]
check == 1
if (check == diag(1)) {
print("Steady State Vector sums to 1")
} else
{
print("Steady State Vector DOES NOT sum to 1")
}
check
diag(1)
c(1)
if (check == c(1)) {
print("Steady State Vector sums to 1")
} else
{
print("Steady State Vector DOES NOT sum to 1")
}
typeof(c(1))
typeof(check)
check == c(1)
print(steady_state_vector)
eigen_vector <- as.double(eigen(M)$vectors[,1])
steady_state_vector <- eigen_vector / sum(eigen_vector)
print(steady_state_vector)
check <- sum(steady_state_vector)
typeof(check)
typeof(c(1))
check == c(1)
if (check == c(1)) {
print("Steady State Vector sums to 1")
} else
{
print("Steady State Vector DOES NOT sum to 1")
}
